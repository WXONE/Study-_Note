## 线性表

在小朋友放学时，幼儿园老师为了保障小朋友们的安全，避免漏掉小朋友，所以给他们安排了出门次序，事先规定好谁在谁前面，谁在谁后面，如果谁没有到位，他前面和后面的小朋友就会主动报告老师。

这种排好队的组织方式，其实就是线性表

### 这里有几个需要强调的地方：

* 首先他是一个序列，也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素没有前驱，最后一个元素没有后继，其他每个元素都有且仅有一个前驱和后继。如果一个小朋友去拉两个小朋友后面的衣服，就排不成一个队列了；同样的，如果一个小朋友后面的衣服，被两个小朋友甚至多个小朋友拉扯，这其实是在打♂架，也构不成有序排列。
* 其次，线性表强调的是有限，小朋友班级人数是有限的，元素个数当然也是有限度的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中。

> 如果用数学的概念来进行定义，语言如下：
>
> 若将线性表记为(a1,......,ai-1,ai,ai+1,......,an),则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素，当i = 1，2，....... ，n-1时，ai有且仅有一个直接后继，当 i = 2，3，.....  ,n时，ai有且仅有一个直接前驱。 所以线性表的元素个数n(n>=0)定义为线性表的长度，当 n = 0 时，称为空表。在非空表中的每个数据元素都有一个确定的位置，如 a1 是第一个数据元素，an时最后一个数据元素，ai是第i个 数据元素，称 i 为数据元素 ai 在线性表中的位序。
>
> ![1540112101718](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540112101718.png)

在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

如：

![1540112330357](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540112330357.png)

### 线性表的抽象数据类型

老师为了让小朋友们有秩序的出入，所以就考虑给他们排一个队，并且是长期使用的顺序，这个考虑和安排的过程其实就是一个线性表的创建和初始化过程。

一开始老师没经验，把小老板们排好队之后，发现有的高有的矮，队伍很难看，于是就让小老板们解散重新排——这是一个把线性表重置为空表的操作。

排好队，我们随时可以叫出队伍某一位置的小朋友名字及他的具体情况。比如有家长问，队伍里第五个麻瓜，怎么这么皮啊，what is his name？老师就可以很快的告诉这位家长，这是韩金龙的儿子，叫韩皮瓜。这种可以根据位序得到数据元素也是一种很重要的线性表操作。

还会有什么呢？有时我们想知道某个小朋友，比如麦兜是否是班里的小朋友，老师会告诉我们说，不是，麦兜在春田花花幼儿园里，不在我们幼儿园。这种查找某个元素是否存在的操作很常用。

而后由家长问老师，班里现在到底有多少个小朋友啊，这种获得线性表长度的问题也很普遍。

显然，对于一个新的幼儿园来说，加入一个新的小朋友到队列中，或因某个小朋友生病，需要移除某个位置，都是很正常的情况。对于一个线性表来说，插入数据和删除数据都是必须的操作。

所以，线性表的抽象数据类型定义如下：

>ADT 线性表(List)
>
>Data
>
>​	线性表的数据对象集合为(a1,......,an)，每个元素的类型均为DataType。其中，除第一个元素 a1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
>
>Operation
>
>​	InitList(*L)：初始化操作，建立一个空的线性表L 。 
>
>​	ListEmpty(L)：若线性表为空，返回true，否则返回false。
>
>......（清空、查找、匹配、插入、删除、统计个数不一一列举）

### 线性表的顺序存储结构

#### 顺序存储定义

让我们来看一下线性表的第一种物理结构——顺序存储结构。

> 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的元素。

线性表（a1......an）的顺序存储示意如下：

![1540112101718](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540112101718.png)

我们在上一节中已经讲过了，我们在举一个例子。

我们平时上课的时候，有些同学喜欢占座，遇到受欢迎的老师的课更是如此，我见过一个同学，他给他舍友（共六人）占座，把他书包里的书一本一本掏出来按座位排好，一个座位放一本书。

#### 顺序存储方式

线性表的顺序存储结构，说白了和刚才的例子一样，就是在内存中找了块地，通过占座的形式，把一定的内存空间给占了。既然线性表的每个数据元素的类型都相同，所以可以用数组来实现顺序存储结构，即把第一个数据元素存储到数组下标为 0 位置中，接着把线性表相邻的元素存储在数组中相邻的位置。

占座者在占座是，如果教室里空位很多，他当然不必选择第一排第一个座，而是可以选择风水，视野都上乘的座。找到后，放一本书在第一个位置，就表示从这开始，这地方暂时是我的。为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，他是存储空间的起始位置。

接着，因为舍友一共六个人，所以他需要占六个座，在线性表中，我们估算这个表的最大存储容量，建立一个数组，数组的长度就是这个最大存储容量。

可现实中，舍友不一定都是热爱学习的，为了睡眠，为了养生，就想去后排补觉，假设宿舍里有六个人，三个人坐在提前占好的座上，真正被使用的座位是三个，另外三个是空的。同样的，我们已经有了起始位置，也有了最大容量，于是我们可以在里面增加数据了。随着数据的插入，我们的线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。

来看线性表的顺序存储的结构代码：

```c
#define MAXSIZE 20 			//存储空间分配
typedef int ElemType		//ElmoType类型根据实际而定，这里假设为int
typedef struct
{
    ElemeType data[MAXSIZE];//数组村塾数据元素，最大值为MAXSIZE
    int lenth;				//线性表当前长度
}SqList;
```

在这里我们就可以发现线性表顺序结构的三个属性：

> * 存储空间固定：数组长度MAXSIZE
> * 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。
> * 线性表当前的长度 length。

在这里要注意一下线性表长度和数据长度，数据的长度即数组的长度，就是存放线性表存储空间的长度，存储空间开辟之后这个量一般是不变的，数组的大小可以动态分配，但是会对性能有一定影响。

线性表的长度就是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

在任意时刻，`线性表长度`小于等于`数组长度`。

#### 地址计算方法

由于线性表是以数组方式存储的，所以线性表第`i`个元素存放在数组下标为`i-1`的位置，即数据元素的序号和存放在它的数组下标之间存在对应关系，用我们数据结构老师的话说，这叫物理上相邻的，逻辑上也相邻。(如图所示)

![1540555065464](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540555065464.png)

用数组存储顺序表意味着要分配固定MAXSIZE空间，由于线性表中可以进行插入和删除，因此分配的数组空间要足够大。

其实内存中的地址都是有编号的，学习过C语言的同学应该都知道定义指针变量之后可以输出变量的地址。**存储器中的每个存储单元都有自己的编号，这个编号称为地址**。当我们占座后，占座的第一个位置确定了，后面的位置都是可以计算的。试想一下我在比赛中的出场顺序是第三个，我后面十个的人的出场顺序是什么呢？当然是4，5，6，7，..... ，13.由于每个数据元素，不管是整型、实型还是字符型，他都是需要占有一定的存储单元空间的。假设占用的是`x`个存储单元，那么线性表中第`i+1`个数据元素的存储位置和第`i`个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。

>LOC(ai+1) = LOC(ai) + x

所以对于第`i`个数据元素ai的存储位置可以由a1推算得出：

>LOC(ai) = LOC(ai) + (i-1)*x

通过这个公式，我们可以算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，我们用时间复杂度来表示。

#### 顺序存储结构的插入与删除

```c
#define MAXSIZE 100
typedef int datatype;
typedef struct{
    datatype a[MAXSIZE];
    int size;//线性表长度
}sequence_list;
```

顺序存储结构示意如图：

![1540629583574](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540629583574.png)



##### 顺序表的初始化----置空表

```c
 void init_sequence_list(sequence_list *slt)
 {    
     slt->size=0;
 }                                          
 #define MAXSIZE 100 
typedef int datatype;
typedef struct
{    datatype a[MAXSIZE]; 
 	 int size; 
}sequence_list;
void init_sequence_list ( sequence_list  *slt ) 
{
    slt->size=0; 
}
void main()
{
   sequence_list *q; 
   q=(sequence_list*)malloc(sizeof(sequence_list)); 
   init_sequence_list (q) ;
   printf("%o,%d",q,q->size); 
}
```

##### 获得元素操作

对于线性表的顺序结构来说，如果我们要实现`GenElem`操作，即将线性表 L 中的第 i 个位置元素值返回，其实是非常简单的。对程序来说，只要 i 的值在数组下标范围内，就是把数组第 i - 1 下标的值返回即可。

```c
// 方法一
int find_num_sequence_list( sequence_list slt, datatype x) 
 {
     int i=0;      /*记录下标*/  
     while( slt.a[i] != x && i<slt.size)    i++; 
     return(i<slt.size ? i : -1);
 }//时间复杂度O(n)
```

```c
//方法二
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status;
//Status 是函数的类型，其值是函数结果状态代码，如OK等
//初始条件：顺序线性表 L 已存在，1<=ListLength(L)
//操作结果：用e返回 L 中第 i 个数据元素的值
Status GetElem (SqList,int i ,ElemType *e)
{
    if(L.length == 0|| i<1 || i>L.length )
        return ERROR;
    *e = L.data[i-1];
    return OK;
}//时间复杂度O(1)
```

注意这里返回值类型 Status 是一个整型，返回 OK 代表 1 ，ERROR 代表 0 ，之后代码中出现就不再详述。

##### 插入操作

刚才我们谈到，这里的时间复杂度为O(1)，现在我们来考虑在线性表指定位置插入新元素该如何操作。

继续刚才幼儿园的例子。现在幼儿园新来了一个小朋友，放学的时候，他想让老师把他安排在第三位，于是对着老师说：“老师老师，我想排在第三个”。小朋友一脸无辜的望着老师，这谁受得了啊，于是老师心一软，让原本第三位的小朋友往后退一步，可是那个小朋友往后退一步，后面所有的小朋友都得退一步，于是从第二位往后，所有的小朋友都往后移了一位，这样，新来的小朋友就排在了第三位的位置。“安排上了！”老师满意地说。

![1540899479532](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540899479532.png)

这个例子已经说明了线性表的顺序存储结构在插入数据时的实现过程。

插入算法的思路：

* 如果插入位置不合适，抛出异常；
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
* 从最后一个元素开始向前遍历到第 i 个位置，分别将他们都向后移动一个位置；
* 将要插入元素填入位置 i 处；
* 表长 +1 ；

```c
int insert_pos_sequence_list(sequence_list *slt, int position, datatype x) 
{
    int i;
    if(slt->size==MAXSIZE)
    { printf("\n full!");  return(-1); }
    if(position<0||position>slt->size) // 0 ≤ position ≤ size 
    { printf("\n指定的插入位置不存在!"); return(0); }
    for(i=slt->size-1; i>=position; i- -)
        slt->a[i+1]=slt->a[i];
    slt->a[position]=x;
    slt->size++;
    return(1);
}//时间复杂度O(n)
```

这代码理解起来很简单，代码原理跟我们举的例子很相似。

#### 删除操作

接着刚才的例子。过了一段时间啊，有个小朋友太皮了，皮断腿，他就没法来上学了，于是在放学排队的时候，他的位置空出来了，他后面的小朋友都往前挪了一步

![1540901026910](D:\数据结构\线性表\%5CUsers%5C41448%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1540901026910.png)

删除算法的思路：

* 如果删除的位置不合理，抛出异常；
* 取出删除元素；
* 从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前挪动一个位置；
* 表长 -1 .

代码如下：

```c
int delete_pos_sequence_list(sequence_list *slt, int position)
{   int i;
 if(slt->size==0)
	{ printf("\n顺序表是空的!");
     return (-1);
    }
 if(position<0||position>=slt->size) // 0 ≤ position ≤ size-1
 { printf("\n指定的删除位置不存在!");
  return (0);
 }
 for( i=position+1; i<=slt->size-1; i++)
     slt->a[i-1]=slt->a[i];
 	 slt->size--;
 	 return (1);
}
```

我们来分析一下算法的时间复杂度：

先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为O(1)，因为不需要移动元素，就如同来了一个新小孩要排在最后或者最后一个小孩皮断腿。

最坏的情况是，如果元素要插入到第 i 个位置，或者删除第 i 个元素，需要移动 n - i 个元素。根据概率原理，每个位置插入或者删除元素的可能性是相同的，也就是说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为 n-1/2.时间复杂度为O(n)。

这说明，线性表的顺序存储结构在存、读数据的时候，不管是哪个位置，时间复杂度都为O(1)。插入和删除的时候，时间复杂度都为O(n)，这说明，他比较适合元素个数变化不大，而更多是存取数据的应用。

#### 线性表顺序存储结构的优缺点

**优点：**

> * 无须表示表内元素之间逻辑关系而增加额外的存储空间
> * 可以快速的存取表中任意位置的元素

**缺点：**

>* 插入和删除操作需要移动大量元素
>* 当线性表长度变化较大时，难以确定存储空间的容量
>* 造成存储空间的 “碎片” 。





















































