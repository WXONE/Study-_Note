# 复制构造函数

当我们定义一个基本类型变量的时候，经常会用一个已经存在的已经有值的变量去初始化新定义的变量，我们定义对象的时候也有这样的需求，就是用一个已经存在的对象去初始化新的对象。

像基本类型的数据，编译器知道如何用已经有值的变量去初始化同类型的变量，如

```c++
int a = 10,b = 10;
int c = a + b;
```

这是因为语法预先定义好的。

而我们自定义的类的类型，该如何去初始化呢，这时候怎么用一个对象去复制新对象，需要由我们自己定义，这时我们要用到c++为我们提供的特殊的构造函数——复制构造函数。

在复制构造函数中，我们可以规定如何用一个已经存在的对象去初始化一个新对象，这个已经有的对象可以用他的引用作为构造函数的参数。如果我们在定义类的时候没有定义复制构造函数，编译器也会为我们生成一个默认的复制构造函数，它会实现两个对象的数据成员之间的一一对应复制，那么这样的一一对应复制很多时候也很不错。

复制构造函数它是一种特殊的构造函数，它的形参必须是本类对象的引用，那么复制构造函数的作用，就是用这个形参构造新的对象。

在类里面，我们可以定义普通的构造函数，它的函数名就是类名，有一个形参表，这个形参表可以是任意格式的形参，任意类型的形参，任意个数的形参都可以，但是接下来我们来看，另一个构造函数就很特殊了，它的参数类型必须是本类对象的引用，而在这个参数前面又加了一个const来限定，加const是因为当我们传递引用作为参数的时候，实际上是可以双向传递数据的，也就是说，接收这个引用参数的函数，它在函数体中，如果对这个形参引用，做了任何修改，那么实参也会被同步修改，显然这不是我们写复制构造函数的目的，我们写复制构造函数是希望用形参引用所指的那个对象去初始化新对象，但绝不希望在这个初始化过程中把原有的那个形参对象给修改了，那么怎么办呢，在这加一个const关键字，这就说明了这个引用是一个常引用我们只能使用这个引用去读取它里的数据，但是不能用这个引用对它指向的对象进行修改，这样既能够传参数进来又能够保证实参的安全性。

```c++
class 类名 {

public :

    类名（形参）；//构造函数

    类名（const  类名 &对象名）；//复制构造函数

    //       ...

}；

类名::类（ const  类名 &对象名）//复制构造函数的实现

{    函数体    }
```

## 复制构造函数被调用的三种情况

* 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；

* 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；

* 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。

  * 这种情况也可以通过移动构造避免不必要的复制





  ## 隐含的复制构造函数

  *  如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。

  *  这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。

  ## “=delete”

  *  如果不希望对象被复制构造

       	*    C++98做法：将复制构造函数声明为private，并且不提供函数的实现。

        *  C++11做法：用“=delete”指示编译器不生成默认复制构造函数。


有时候呢我们不希望对象被复制构造，那这个时候按照C++98标准的做法我们就可以将复制构造函数声明为私有的private类型，并且不提供函数体的实现。在C++11中有更好更方便的办法，就是用delete关键字来指示编译器不生成默认的复制构造函数。

```c++
class Point {   //Point 类的定义

public:

    Point(int xx=0, int yy=0) { x = xx; y = yy; }    //构造函数，内联

    Point(const Point& p) =delete;  //指示编译器不生成默认复制构造函数

private:

    int x, y; //私有数据

};
```

